# 第 9 章 排序

1. 排序的稳定性：在排序的过程中，可能会出现两个记录的关键字相等的情况，那么此时如果排序后两个记录的先后顺序没有变化，则说明排序是稳定的，否则排序就是非稳定的。
2. 内排序和外排序：根据排序过程中，是否所有记录都存放在内存中，可将排序分为内排序和外排序。

## 冒泡排序

冒泡排序是一种**交换排序**，基本思想是两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录。

```cpp
void bubble_sort(vector<int> &nums){
    int n = nums.size();
    //两两比较相邻记录的关键字，如果反序则交换，直到没有反序的记录。
    //一次循环确定一个记录的位置，那么一共需要 n - 1 次循环
    for(int i = 0; i < n - 1; ++i){
        for(int j = n - 2;j >= i;--j){
            if(nums[j] > nums[j + 1]){
                swap(nums[j], nums[j+1]);
            }
        }
    }
    return;
}
```

## 简单选择排序

**选择排序**的基本思想是每一次在 `n - i + 1` 个（第 i 次）记录中选取关键字最小的记录作为有序序列的第 `i` 个记录。简单选择排序就是通过  `n - i` 次比较，从记录中选取关键字最小的记录，然后与第 `i` 个记录进行交换。

```cpp
void select_sort(vector<int> &nums){
    int n = nums.size();
    for(int i = 0;i < n;++i){
        int min_index = i;
        for(int j = i + 1;j < n;++j){
            if(nums[j] < nums[min_index]){
                min_index = j;
            }
        }
        // 下标为 i 的不是最小的，需要交换
        if(min_index != i){
            swap(nums[i], nums[min_index]);
        }
    }
    return;
}
```

## 直接插入排序

直接插入排序的基本思想是我们已经有一个有序的序列，每一次操作将一个记录插入到适当的位置，从而得到一个新的、记录数增加 1 的有序表。

```cpp
void insert_sort(vector<int> &nums){
    int n = nums.size();
    //第一个元素必然有序，现在需要将 nums[i] 插入到前面的某个位置
    for(int i = 1; i < n;i++){
        //如果比 nums[i - 1] 还大，直接插入末尾即可
        //否则，找到插入位置，在这个过程中需要
        if(nums[i] < nums[i - 1]){
            int insert_num = nums[i];
            int j = i - 1;
            for(;j >= 0 && insert_num < nums[j];j--){
                nums[j + 1] = nums[j];
            }
            //找到了该插入的位置，将元素进行插入
            nums[j + 1] = insert_num;
        }
    }
    return;
}
```

## 希尔排序

直接插入排序也是 $$O(n^2)$$ 的时间复杂度，但是在序列基本有序的时候以及数据量较少的情况下，它会有较大的优势，虽然在现实生活中这些情况都属于特殊情况，但是我们可以手动的去创造这些情况。希尔排序就是利用了这样的思想，将整个序列分成一些子序列，针对每一个子序列进行直接插入排序，当整个序列都基本有序的时候，再针对整个序列进行直接插入排序。

我们的目标是为了让数据量较少，那么直接通过分组产生子序列可以实现；同时我们还需要让每个子序列中的数据基本有序，这就需要一些分组策略。在希尔排序中，使用了**跳跃分割**的策略，即将相距某个“增量”的记录组成一个子序列。对于增量值的选取，目前还是一个难题，但是增量序列的最后一个值一定要是1.(相当于直接插入排序)

```cpp
void shell_sort(vector<int> &nums){
    int n = nums.size();
    int increment = n / 2;
    //最外层的循环，来进行 increment 序列的变化，每次除以 2 能保证 increment 序列中有 1
    while(increment > 0){
        //选择每一组的数据来进行插入排序
        for(int i = increment; i < n;++i){
            //针对每一个数据，找到它在其所在组的位置，这里是组之间交替进行的，并不是每次处理完一个组，而是针对元素
            //需要找到 nums[i] 的插入位置，不能直接插入在后面
            if(nums[i] < nums[i - increment]){
                int insert_num = nums[i];
                int j = i - increment;
                for(;j >= 0 && insert_num < nums[j];j = j - increment){
                    nums[j + increment] = nums[j];
                }
                //找到了插入的位置
                nums[j + increment] = insert_num;
            }
        }
        increment = increment / 2;
    }
    return;
}
```

##  堆排序

堆是具有下列性质的**完全二叉树**：每个节点的值都大于或等于其左右孩子节点的值（大顶堆）；每个节点的值都小于或等于其左右孩子节点的值（小顶堆）。

堆排序就是利用堆这种数据结构来进行排序，cpp的标准库中提供了 `priority_queue` ，就是一个堆结构，这里我们通过数组来模拟堆，从而实现排序。使用数组模拟的时候，我们让根节点下标为 `i`，那么每个节点的左孩子和右孩子下标则为 `2i + 1 和 2i + 2`。

```cpp
void max_heapify(vector<int> &nums, int start, int end){
    //负责调整数组内容，使得 nums[start ... end] 是一个大顶堆
    int dad = start;
    int left_son = 2 * dad + 1;
    //下标的范围在区间内再考虑
    while(left_son <= end){
        //选择孩子中关键字较大的孩子
        int choice_son = left_son;
        int right_son = left_son + 1;
        if(right_son <= end && nums[right_son] > nums[left_son]){
            choice_son = right_son;
        }
        //父亲节点比儿子节点大，不需要调整
        if(nums[dad] > nums[choice_son]){
            return; 
        }
        //调整，然后继续调整子树
        else{
            swap(nums[dad], nums[choice_son]);
            dad = choice_son;
            left_son = 2 * dad + 1;
        }
    }
}
void heap_sort(vector<int> &nums){
    int n = nums.size();
    //从最后一个父节点开始调整，最后一个节点的下标是 n - 1
    //若为左孩子，n 为偶数，则 2 * dad + 1 = n - 1, dad = (n - 2) / 2 = n / 2 - 1
    //若为右孩子，n 为奇数，则 2 * dad + 2 = n - 1, dad = (n - 3) / 2 = (n - 1) / 2 - 1 = n / 2 - 1
    //综上： dad = n / 2 - 1
    for(int i = n / 2 - 1; i >= 0; --i){
        max_heapify(nums, i, n - 1);
    }
    for(int i = 0;i < nums.size();++i){
        cout << nums[i] << "\n";
    }
    for(int i = n - 1; i > 0; --i){
        swap(nums[0], nums[i]); //与根节点交换，然后进行调整
        max_heapify(nums, 0, i - 1);
    }
}
```

## 归并排序

堆排序利用了完全二叉树，归并排序可以理解为一棵倒置的二叉树，对于每一个元素，如果只有它自己，那么就是有序的，然后我们两两合并，就可以将 n 个数据合并成 n / 2 个序列，其中每个序列中有 2 个元素，且有序，就这样一直合并下去，就可以得到一个长度为 n  的有序序列。（二路归并排序）

```cpp
void merge_sort(vector<int> &nums, int start, int end){
    //递归退出条件，此处是[start, end]，左闭右闭
    if(start >= end) return;
    //进行递归
    int mid = start + (end - start) / 2;
    merge_sort(nums, start, mid);
    merge_sort(nums, mid + 1, end);
    //上述过程结束以后，我们得到了 [start, mid]，[mid + 1, end] 两个有序数组，问题就转化为了合并有序数组
    merge(nums, start, mid, end);
}
void merge(vector<int> &nums, int start, int mid, int end){
    //使用辅助数组分别存放这两个有序数组
    vector<int> leftArray(nums.begin() + start, nums.begin() + mid + 1);
    vector<int> rightArray(nums.begin() + mid + 1, nums.begin() + end + 1);
    //合并两个有序数组
    int leftId = 0, rightId = 0;
    int i;
    for(i = start;i <= end && leftId < leftArray.size() && rightId < rightArray.size();i++){
        if(leftArray[leftId] < rightArray[rightId]){
            nums[i] = leftArray[leftId];
            leftId++;
        }
        else{
            nums[i] = rightArray[rightId];
            rightId++;
        }
    }
    while(leftId < leftArray.size()){
        nums[i] = leftArray[leftId];
        i++;
        leftId++;
    }
    while(rightId < rightArray.size()){
        nums[i] = rightArray[rightId];
        i++;
        rightId++;
    }
    return ;
}
```

## 快速排序

快速排序的基本思路是通过一趟排序将待排序记录分割成独立的两个部分，其中一部分记录的关键字均比另一部分记录的关键字小，从而可以分别再对这两部分进行排序，最终达到整个序列有序。此处我们选择每个序列的首元素作为基准元素，所以我们先从后往前遍历，遇到小于 base 的就可以将其放在序列的首元素位置。

```cpp
void quick_sort(vector<int>& nums, int start, int end){
    //左闭右闭，排序 nums[start, end] 使得左侧都比基准元素小，右侧都比基准元素大
    //递归退出条件
    if(start >= end) return;
    //初始化基准元素，左右指针
    int base = nums[start], l = start, r = end;
    while(l < r){
        while(l < r && nums[r] >= base){
            r--;
        }
        nums[l] = nums[r]; //此时 nums[r] 比 base 小
        while(l < r && nums[l] <= base){
            l++;
        }
        nums[r] = nums[l]; //此时 nums[l] 比 base 大
    }
    // l == r，即 base 的位置
    nums[l] = base;
    //递归
    quick_sort(nums, start, l - 1);
    quick_sort(nums, l + 1, end);

}
```

